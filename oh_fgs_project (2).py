# -*- coding: utf-8 -*-
"""OH-FGS  Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c7vmzYncGBP226UiQpgEo9lBgZeJD1wQ

IMPORT LIBRARIES
"""

# 2. Import libraries
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from xgboost import XGBClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.metrics import classification_report, roc_auc_score
import matplotlib.pyplot as plt
import seaborn as sns
import joblib

# 3. Load dataset (upload your Excel file when prompted)
import streamlit as st
import pandas as pd

uploaded_file = st.file_uploader("Upload OH-FGS Excel file", type=["xlsx"])
if uploaded_file:
    df = pd.read_excel(uploaded_file)
    st.write(df.head())
else:
    st.warning("Please upload an Excel file")

# 4. Feature Selection (One Health Approach)
# Key variables from your dataset + engineered features
one_health_features = [
    # Human Health
    'n_ShInfection',       # Primary target (binary: outbreak if >50)
    'mean_ShEgg',          # Egg burden (continuous)
    'n_female',            # FGS risk group
    'Pop',                 # Population density

    # Environmental
    'LakeYN',              # Lake presence (binary)
    'distance',            # Proximity to water (meters)
    'FloatingVeg',         # Snail habitat indicator
    'Depth',               # Water depth (snail survival)
    'width_shore',         # Shoreline width (transmission zone)

    # Animal/Vector
    'Bulinus',             # Snail vector count
    'Biomph',              # Alternative snail vector
    'circ_score'           # Water body circularity (snail habitat)
]

# Create new features
df['water_contact_risk'] = np.where(df['distance'] < 1000, 1, 0)  # High risk if <1km to water
df['snail_density'] = df['Bulinus'] + df['Biomph']               # Total snail load

# 5. Prepare data
X = df[one_health_features]
y = np.where(df['n_ShInfection'] > 50, 1, 0)  # Binary outbreak target (1 if >50 cases)

# 6. Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=42)

# 7. Train model (Random Forest)
rf_model = RandomForestClassifier(n_estimators=100, class_weight='balanced', random_state=42)
rf_model.fit(X_train, y_train)

dt_model = DecisionTreeClassifier(random_state=42)
dt_model.fit(X_train, y_train)

xg_model = XGBClassifier(random_state=42)
xg_model.fit(X_train, y_train)

lg_model = LogisticRegression(random_state=42)
lg_model.fit(X_train, y_train)

# 8. Evaluate

#Evaluate Random Forest model
y_pred_rf = rf_model.predict(X_test)
print("Random Forest Model Evaluation:")
print(classification_report(y_test, y_pred_rf))
print(f"AUC-ROC: {roc_auc_score(y_test, rf_model.predict_proba(X_test)[:, 1]):.2f}")

# Evaluate Decision Tree model
y_pred_dt = dt_model.predict(X_test)
print("Decision Tree Model Evaluation:")
print(classification_report(y_test, y_pred_dt))
print(f"AUC-ROC: {roc_auc_score(y_test, dt_model.predict_proba(X_test)[:, 1]):.2f}")

# Evaluate XGBoost model
y_pred_xg = xg_model.predict(X_test)
print("\nXGBoost Model Evaluation:")
print(classification_report(y_test, y_pred_xg))
print(f"AUC-ROC: {roc_auc_score(y_test, xg_model.predict_proba(X_test)[:, 1]):.2f}")

# Evaluate Logistic Regression model
y_pred_lg = lg_model.predict(X_test)
print("\nLogistic Regression Model Evaluation:")
print(classification_report(y_test, y_pred_lg))
print(f"AUC-ROC: {roc_auc_score(y_test, lg_model.predict_proba(X_test)[:, 1]):.2f}")

# 9. Feature Importance
plt.figure(figsize=(10, 6))
sns.barplot(x=rf_model.feature_importances_, y=one_health_features)
plt.title("One Health Feature Importance")
plt.show()

import seaborn as sns
df['risk_score'] = lg_model.predict_proba(X)[:, 1]

# Now, the heatmap code should work
# Pivot table: Village x Site risk scores
heatmap_data = df.pivot_table(index='Village', columns='Site',
                             values='risk_score', aggfunc='mean')

# Plot
plt.figure(figsize=(12, 8))
sns.heatmap(heatmap_data, annot=True, cmap="YlOrRd",
            linewidths=0.5, cbar_kws={'label': 'Risk Score'})
plt.title("Schisto Risk by Village and Site")
plt.show()

import pickle

# Save the model
chosen_model = lg_model
with open('schisto_risk_model.pkl', 'wb') as f:
    pickle.dump(chosen_model, f)

print("LGR model saved as schisto_risk_model.pkl")

def send_stakeholder_alerts(village_data, risk_level):
    # Single recipient (modify this to your target email)
    recipient_email = "freitasannie7@gmail.com"

    # Compose the alert message
    message = f"""
    üö® SCHISTOSOMIASIS ALERT - {village_data['Village']} üö®
    Risk Level: {risk_level}
    Risk Score: {village_data['risk_score']:.2f}

    üìç Location: Site {village_data['Site']}
    üìä Metrics:
    - Infected Individuals: {village_data['n_ShInfection']}
    - Bulinus Snail Count: {village_data['Bulinus']}
    - Water Contact Risk: {village_data['distance']}m from village

    ‚ö†Ô∏è Recommended Actions:
    {generate_intervention_plan(village_data)}

    üìÖ Next Assessment: {pd.Timestamp.now() + pd.Timedelta(days=7)}
    """

    # Send only one email
    send_email(recipient_email, f"SCHISTO ALERT: {risk_level} Risk Detected", message)

    # Optional: Log the alert (no SMS or emergency protocols)
    print(f"üìß Alert sent to {recipient_email} for {village_data['Village']}")

import pandas as pd
import numpy as np

# Track Intervention Effectiveness
def evaluate_impact(baseline, follow_up):
    improvement = {
        'Risk Reduction': baseline['risk_score'] - follow_up['risk_score'],
        'Case Reduction': (baseline['n_ShInfection'] - follow_up['n_ShInfection'])/baseline['n_ShInfection']*100,
        'Snail Reduction': (baseline['Bulinus'] - follow_up['Bulinus'])/baseline['Bulinus']*100
    }
    return improvement

# Example Report
# Replace 'Diokhor' with an actual Village name from your dataset (e.g., 'Diokhor ')
baseline = df[df['Village']=='Diokhor '].iloc[0]
follow_up = baseline.copy()  # Replace with actual follow-up data
follow_up.update({'risk_score': baseline['risk_score']*0.6,
                 'n_ShInfection': baseline['n_ShInfection']*0.7,
                 'Bulinus': baseline['Bulinus']*0.5})

print("üìà Intervention Effectiveness:")
st.dataframe(pd.DataFrame([evaluate_impact(baseline, follow_up)]))

# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import numpy as np
import pickle
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LogisticRegression

# Set page config
st.set_page_config(
    page_title="OH-FGS Risk Predictor",
    page_icon="ü¶†",
    layout="wide"
)

# Original feature names the model expects
ORIGINAL_FEATURES = [
    'n_ShInfection', 'mean_ShEgg', 'n_female', 'Pop', 'LakeYN',
    'distance', 'FloatingVeg', 'Depth', 'width_shore', 'Bulinus',
    'Biomph', 'circ_score'
]

# Custom CSS
st.markdown("""
    <style>
        .high-risk { background-color: #ffcccc; padding: 10px; border-radius: 5px; }
        .medium-risk { background-color: #fff3cd; padding: 10px; border-radius: 5px; }
        .low-risk { background-color: #d4edda; padding: 10px; border-radius: 5px; }
        .stNumberInput > div > div > input {background-color: #f0f2f6;}
        .stTextInput > div > div > input {background-color: #f0f2f6;}
        .stSelectbox > div > div {background-color: #f0f2f6;}
    </style>
""", unsafe_allow_html=True)

# Load pre-trained model
@st.cache_resource
def load_model():
    try:
        with open('schisto_risk_model.pkl', 'rb') as f:
            model = pickle.load(f)
        st.success("Pre-trained model loaded successfully!")
        return model
    except:
        st.warning("Using default model - for best results, train with your local data")
        model = LogisticRegression()
        # Create dummy data matching the original feature set
        X_dummy = np.random.rand(100, len(ORIGINAL_FEATURES))
        y_dummy = (X_dummy.sum(axis=1) > 6).astype(int)
        model.fit(pd.DataFrame(X_dummy, columns=ORIGINAL_FEATURES), y_dummy)
        return model

def main():
    st.title("ü¶† OH-FGS Risk Prediction System")
    
    # Load model
    model = load_model()
    
    # Data entry form
    with st.form("risk_prediction_form"):
        st.header("Enter Location Parameters")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Human Health Factors")
            n_ShInfection = st.number_input("Number of Infections", min_value=0, value=25)
            mean_ShEgg = st.number_input("Mean Egg Burden", min_value=0.0, value=10.5)
            n_female = st.number_input("Number of Females at Risk", min_value=0, value=15)
            Pop = st.number_input("Population Density", min_value=0, value=200)
            
        with col2:
            st.subheader("Environmental Factors")
            LakeYN = st.selectbox("Lake Present", ["No", "Yes"], index=1)
            distance = st.number_input("Distance to Water (meters)", min_value=0, value=500)
            FloatingVeg = st.slider("Floating Vegetation Index", 0.0, 1.0, 0.75)
            Depth = st.number_input("Water Depth (meters)", min_value=0.0, value=1.2)
            width_shore = st.number_input("Shoreline Width (meters)", min_value=0.0, value=5.5)
            
        st.subheader("Vector Factors")
        col3, col4 = st.columns(2)
        with col3:
            Bulinus = st.number_input("Bulinus Snail Count", min_value=0, value=30)
            Biomph = st.number_input("Biomph Snail Count", min_value=0, value=15)
        with col4:
            circ_score = st.slider("Water Body Circularity (0=irregular, 1=circular)", 0.0, 1.0, 0.6)
        
        location_name = st.text_input("Location Name", value="Village A")
        
        submitted = st.form_submit_button("Predict Risk")
    
    if submitted:
        try:
            # Prepare input data with ONLY the original features
            input_data = {
                'n_ShInfection': n_ShInfection,
                'mean_ShEgg': mean_ShEgg,
                'n_female': n_female,
                'Pop': Pop,
                'LakeYN': 1 if LakeYN == "Yes" else 0,
                'distance': distance,
                'FloatingVeg': FloatingVeg,
                'Depth': Depth,
                'width_shore': width_shore,
                'Bulinus': Bulinus,
                'Biomph': Biomph,
                'circ_score': circ_score
            }
            
            # Convert to dataframe with correct feature order
            X = pd.DataFrame([input_data], columns=ORIGINAL_FEATURES)
            
            # Get prediction (using only original features)
            risk_score = float(model.predict_proba(X)[:, 1][0])
            
            # Display results
            st.success("Risk assessment completed!")
            
            # Risk level determination
            if risk_score > 0.7:
                risk_level = "High"
                risk_class = "high-risk"
            elif risk_score > 0.3:
                risk_level = "Medium"
                risk_class = "medium-risk"
            else:
                risk_level = "Low" 
                risk_class = "low-risk"
            
            # Show risk assessment
            st.markdown(f"""
                <div class="{risk_class}">
                    <h2>{location_name} Risk Assessment: {risk_level}</h2>
                    <h3>Risk Probability: {risk_score:.1%}</h3>
                </div>
            """, unsafe_allow_html=True)
            
            # Calculate derived features for visualization only
            snail_density = Bulinus + Biomph
            water_contact_risk = 1 if distance < 1000 else 0
            
            # Visualization section
            st.header("Risk Visualization")
            
            fig, ax = plt.subplots(1, 2, figsize=(15, 5))
            
            # Risk factors bar chart (using original + derived for display)
            risk_factors = {
                'Infections': n_ShInfection/100,
                'Egg Burden': mean_ShEgg/50,
                'Population': Pop/1000,
                'Water Contact': water_contact_risk,
                'Snail Density': snail_density/50
            }
            sns.barplot(x=list(risk_factors.keys()), y=list(risk_factors.values()), ax=ax[0])
            ax[0].set_title("Key Risk Factors")
            ax[0].set_ylim(0, 1)
            
            # Risk gauge
            ax[1].set_xlim(0, 1)
            ax[1].set_ylim(0, 1)
            ax[1].add_patch(plt.Rectangle((0, 0), 1, 0.3, color='green', alpha=0.3))
            ax[1].add_patch(plt.Rectangle((0, 0.3), 1, 0.4, color='orange', alpha=0.3))
            ax[1].add_patch(plt.Rectangle((0, 0.7), 1, 0.3, color='red', alpha=0.3))
            ax[1].plot([risk_score, risk_score], [0, 1], 'k-', lw=3)
            ax[1].text(risk_score, 1.05, f"{risk_score:.0%}", ha='center')
            ax[1].set_title("Risk Level Gauge")
            ax[1].axis('off')
            
            st.pyplot(fig)
            
            # Intervention recommendations
            st.header("Recommended Interventions")
            
            if risk_level == "High":
                st.warning("""
                **üö® Immediate Actions Required:**
                - Conduct emergency MDA (mass drug administration)
                - Implement snail control (niclosamide treatment)
                - Distribute water filters to all households
                - Daily monitoring of water contact points
                - Community-wide health education campaign
                """)
                
            elif risk_level == "Medium":
                st.info("""
                **‚ö†Ô∏è Recommended Actions:**
                - Targeted treatment of high-risk groups
                - Environmental modification to reduce snail habitats
                - School-based health education
                - Improve sanitation facilities
                - Monthly monitoring
                """)
                
            else:
                st.success("""
                **üü¢ Preventive Measures:**
                - Routine health education sessions
                - Basic sanitation improvements
                - Annual screening program
                - Community awareness activities
                """)
            
            # Data summary
            st.header("Input Summary")
            display_data = input_data.copy()
            display_data['snail_density'] = snail_density
            display_data['water_contact_risk'] = water_contact_risk
            st.dataframe(pd.DataFrame([display_data]))
            
        except Exception as e:
            st.error(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()
