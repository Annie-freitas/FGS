# -*- coding: utf-8 -*-
"""OH-FGS  Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c7vmzYncGBP226UiQpgEo9lBgZeJD1wQ

IMPORT LIBRARIES
"""

# 1. Install required libraries
!pip install pandas scikit-learn matplotlib seaborn joblib
# Install required packages
!pip install pygam pgmpy pysal geopandas libpysal

# 2. Import libraries
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from xgboost import XGBClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.metrics import classification_report, roc_auc_score
import matplotlib.pyplot as plt
import seaborn as sns
import joblib

# 3. Load dataset (upload your Excel file when prompted)
df = pd.read_excel('/content/OH-FGS.xlsx')

# 4. Feature Selection (One Health Approach)
# Key variables from your dataset + engineered features
one_health_features = [
    # Human Health
    'n_ShInfection',       # Primary target (binary: outbreak if >50)
    'mean_ShEgg',          # Egg burden (continuous)
    'n_female',            # FGS risk group
    'Pop',                 # Population density

    # Environmental
    'LakeYN',              # Lake presence (binary)
    'distance',            # Proximity to water (meters)
    'FloatingVeg',         # Snail habitat indicator
    'Depth',               # Water depth (snail survival)
    'width_shore',         # Shoreline width (transmission zone)

    # Animal/Vector
    'Bulinus',             # Snail vector count
    'Biomph',              # Alternative snail vector
    'circ_score'           # Water body circularity (snail habitat)
]

# Create new features
df['water_contact_risk'] = np.where(df['distance'] < 1000, 1, 0)  # High risk if <1km to water
df['snail_density'] = df['Bulinus'] + df['Biomph']               # Total snail load

# 5. Prepare data
X = df[one_health_features]
y = np.where(df['n_ShInfection'] > 50, 1, 0)  # Binary outbreak target (1 if >50 cases)

# 6. Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=42)

# 7. Train model (Random Forest)
rf_model = RandomForestClassifier(n_estimators=100, class_weight='balanced', random_state=42)
rf_model.fit(X_train, y_train)

dt_model = DecisionTreeClassifier(random_state=42)
dt_model.fit(X_train, y_train)

xg_model = XGBClassifier(random_state=42)
xg_model.fit(X_train, y_train)

lg_model = LogisticRegression(random_state=42)
lg_model.fit(X_train, y_train)

# 8. Evaluate

#Evaluate Random Forest model
y_pred_rf = rf_model.predict(X_test)
print("Random Forest Model Evaluation:")
print(classification_report(y_test, y_pred_rf))
print(f"AUC-ROC: {roc_auc_score(y_test, rf_model.predict_proba(X_test)[:, 1]):.2f}")

# Evaluate Decision Tree model
y_pred_dt = dt_model.predict(X_test)
print("Decision Tree Model Evaluation:")
print(classification_report(y_test, y_pred_dt))
print(f"AUC-ROC: {roc_auc_score(y_test, dt_model.predict_proba(X_test)[:, 1]):.2f}")

# Evaluate XGBoost model
y_pred_xg = xg_model.predict(X_test)
print("\nXGBoost Model Evaluation:")
print(classification_report(y_test, y_pred_xg))
print(f"AUC-ROC: {roc_auc_score(y_test, xg_model.predict_proba(X_test)[:, 1]):.2f}")

# Evaluate Logistic Regression model
y_pred_lg = lg_model.predict(X_test)
print("\nLogistic Regression Model Evaluation:")
print(classification_report(y_test, y_pred_lg))
print(f"AUC-ROC: {roc_auc_score(y_test, lg_model.predict_proba(X_test)[:, 1]):.2f}")

# 9. Feature Importance
plt.figure(figsize=(10, 6))
sns.barplot(x=rf_model.feature_importances_, y=one_health_features)
plt.title("One Health Feature Importance")
plt.show()

import seaborn as sns
df['risk_score'] = lg_model.predict_proba(X)[:, 1]

# Now, the heatmap code should work
# Pivot table: Village x Site risk scores
heatmap_data = df.pivot_table(index='Village', columns='Site',
                             values='risk_score', aggfunc='mean')

# Plot
plt.figure(figsize=(12, 8))
sns.heatmap(heatmap_data, annot=True, cmap="YlOrRd",
            linewidths=0.5, cbar_kws={'label': 'Risk Score'})
plt.title("Schisto Risk by Village and Site")
plt.show()

import pickle

# Save the model
chosen_model = lg_model
with open('schisto_risk_model.pkl', 'wb') as f:
    pickle.dump(chosen_model, f)

print("LGR model saved as schisto_risk_model.pkl")

def send_stakeholder_alerts(village_data, risk_level):
    # Single recipient (modify this to your target email)
    recipient_email = "freitasannie7@gmail.com"

    # Compose the alert message
    message = f"""
    üö® SCHISTOSOMIASIS ALERT - {village_data['Village']} üö®
    Risk Level: {risk_level}
    Risk Score: {village_data['risk_score']:.2f}

    üìç Location: Site {village_data['Site']}
    üìä Metrics:
    - Infected Individuals: {village_data['n_ShInfection']}
    - Bulinus Snail Count: {village_data['Bulinus']}
    - Water Contact Risk: {village_data['distance']}m from village

    ‚ö†Ô∏è Recommended Actions:
    {generate_intervention_plan(village_data)}

    üìÖ Next Assessment: {pd.Timestamp.now() + pd.Timedelta(days=7)}
    """

    # Send only one email
    send_email(recipient_email, f"SCHISTO ALERT: {risk_level} Risk Detected", message)

    # Optional: Log the alert (no SMS or emergency protocols)
    print(f"üìß Alert sent to {recipient_email} for {village_data['Village']}")

import pandas as pd
import numpy as np

# Track Intervention Effectiveness
def evaluate_impact(baseline, follow_up):
    improvement = {
        'Risk Reduction': baseline['risk_score'] - follow_up['risk_score'],
        'Case Reduction': (baseline['n_ShInfection'] - follow_up['n_ShInfection'])/baseline['n_ShInfection']*100,
        'Snail Reduction': (baseline['Bulinus'] - follow_up['Bulinus'])/baseline['Bulinus']*100
    }
    return improvement

# Example Report
# Replace 'Diokhor' with an actual Village name from your dataset (e.g., 'Diokhor ')
baseline = df[df['Village']=='Diokhor '].iloc[0]
follow_up = baseline.copy()  # Replace with actual follow-up data
follow_up.update({'risk_score': baseline['risk_score']*0.6,
                 'n_ShInfection': baseline['n_ShInfection']*0.7,
                 'Bulinus': baseline['Bulinus']*0.5})

print("üìà Intervention Effectiveness:")
display(pd.DataFrame([evaluate_impact(baseline, follow_up)]))

# Install required libraries
!pip install streamlit plotly geopandas

import streamlit as st
import pandas as pd
import numpy as np
import pickle
import plotly.express as px
import geopandas as gpd
from shapely.geometry import Point
import tempfile
import os

# Set page config
st.set_page_config(
    page_title="AI OH-FGS Predict",
    page_icon="ü¶†",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for styling
st.markdown("""
    <style>
        .main {
            background-color: #f5f5f5;
        }
        .stAlert {
            padding: 20px;
            border-radius: 10px;
        }
        .high-risk {
            background-color: #ffcccc;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        .medium-risk {
            background-color: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        .low-risk {
            background-color: #d4edda;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        .header {
            color: #2c3e50;
        }
    </style>
""", unsafe_allow_html=True)

# Load the trained model
@st.cache_resource
def load_model():
    with open('schisto_risk_model.pkl', 'rb') as f:
        model = pickle.load(f)
    return model

model = load_model()

# Expected feature names based on your model
EXPECTED_FEATURES = [
    'n_ShInfection', 'mean_ShEgg', 'n_female', 'Pop', 'LakeYN',
    'distance', 'FloatingVeg', 'Depth', 'width_shore', 'Bulinus',
    'Biomph', 'circ_score'
]

# Function to process uploaded data
def process_data(uploaded_file):
    try:
        df = pd.read_csv(uploaded_file)

        # Check if required columns are present
        missing_cols = [col for col in EXPECTED_FEATURES if col not in df.columns]
        if missing_cols:
            st.error(f"Missing required columns in the dataset: {', '.join(missing_cols)}")
            return None

        return df
    except Exception as e:
        st.error(f"Error reading file: {str(e)}")
        return None

# Function to make predictions
def make_predictions(df):
    try:
        # Prepare features
        features = df[EXPECTED_FEATURES]

        # Make predictions
        predictions = model.predict(features)
        probabilities = model.predict_proba(features)[:, 1]  # Probability of positive class

        # Add to dataframe
        df['Risk_Prediction'] = predictions
        df['Risk_Probability'] = probabilities

        # Add risk level based on probability
        df['Risk_Level'] = pd.cut(
            df['Risk_Probability'],
            bins=[0, 0.3, 0.7, 1],
            labels=['Low', 'Medium', 'High'],
            include_lowest=True
        )

        return df
    except Exception as e:
        st.error(f"Error making predictions: {str(e)}")
        return None

# Function to create map visualization
def create_map(df):
    try:
        # Check if we have coordinates - assuming 'latitude' and 'longitude' columns
        if 'latitude' not in df.columns or 'longitude' not in df[['longitude']].columns:
            st.warning("No latitude/longitude columns found for mapping.")
            return None

        # Create a GeoDataFrame
        geometry = [Point(xy) for xy in zip(df['longitude'], df['latitude'])]
        gdf = gpd.GeoDataFrame(df, geometry=geometry)

        # Create interactive plot
        fig = px.scatter_mapbox(
            gdf,
            lat='latitude',
            lon='longitude',
            color='Risk_Level',
            color_discrete_map={
                'Low': 'green',
                'Medium': 'orange',
                'High': 'red'
            },
            hover_name='Risk_Level',
            hover_data=EXPECTED_FEATURES,
            zoom=10,
            height=600,
            title='Schistosomiasis Risk Distribution'
        )

        fig.update_layout(
            mapbox_style="open-street-map",
            margin={"r":0,"t":40,"l":0,"b":0},
            hovermode='closest'
        )

        return fig
    except Exception as e:
        st.error(f"Error creating map: {str(e)}")
        return None

# Main app
def main():
    st.title("ü¶† OH-FGS Risk Prediction System")
    st.markdown("""
        This system predicts the risk of schistosomiasis infection based on environmental and demographic factors.
        Upload your data below to get predictions and visualize risk areas.
    """)

    # File upload
    uploaded_file = st.file_uploader("Upload CSV file with schistosomiasis risk factors", type=['csv'])

    if uploaded_file is not None:
        # Process data
        df = process_data(uploaded_file)

        if df is not None:
            st.success("Data successfully loaded!")

            # Show preview
            st.subheader("Data Preview")
            st.write(df.head())

            # Make predictions
            st.subheader("Risk Prediction")
            if st.button("Run Predictions"):
                with st.spinner("Making predictions..."):
                    result_df = make_predictions(df)

                    if result_df is not None:
                        st.success("Predictions completed!")

                        # Show results
                        st.write(result_df[['Risk_Prediction', 'Risk_Probability', 'Risk_Level']].head())

                        # Risk summary
                        st.subheader("Risk Distribution")
                        risk_counts = result_df['Risk_Level'].value_counts()
                        st.bar_chart(risk_counts)

                        # Show high risk alerts
                        high_risk = result_df[result_df['Risk_Level'] == 'High']
                        if not high_risk.empty:
                            st.subheader("üö® High Risk Alerts")
                            st.write(f"Found {len(high_risk)} high risk locations:")
                            st.dataframe(high_risk[EXPECTED_FEATURES + ['Risk_Probability']])

                        # Create and show map
                        st.subheader("Risk Map Visualization")
                        map_fig = create_map(result_df)
                        if map_fig:
                            st.plotly_chart(map_fig, use_container_width=True)

                        # Download results
                        st.subheader("Download Results")
                        with tempfile.NamedTemporaryFile(delete=False, suffix='.csv') as tmp:
                            result_df.to_csv(tmp.name, index=False)
                            with open(tmp.name, 'rb') as f:
                                st.download_button(
                                    label="Download Predictions",
                                    data=f,
                                    file_name="schisto_risk_predictions.csv",
                                    mime="text/csv"
                                )
                            os.unlink(tmp.name)
        else:
            st.error("Please check your data format and try again.")

    # Sidebar with information
    st.sidebar.title("About")
    st.sidebar.info("""
        **Schistosomiasis Risk Prediction System**
        This tool uses machine learning to predict the risk of schistosomiasis infection based on environmental factors.

        Expected features in your data:
        - n_ShInfection
        - mean_ShEgg
        - n_female
        - Pop
        - LakeYN
        - distance
        - FloatingVeg
        - Depth
        - width_shore
        - Bulinus
        - Biomph
        - circ_score

        For best results, include latitude/longitude columns for mapping.
    """)

if __name__ == "__main__":
    main()

!pip install streamlit plotly geopandas